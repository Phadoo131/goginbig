// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: returnandborrow.sql

package db

import (
	"context"
)

const createrReturnAndBorrow = `-- name: CreaterReturnAndBorrow :one
INSERT INTO returnandborrow (
  from_account_id,
  book,
  bookcount
) VALUES (
  $1, $2, $3
)
RETURNING id, from_account_id, book, bookcount, created_at
`

type CreaterReturnAndBorrowParams struct {
	FromAccountID int64  `json:"fromAccountId"`
	Book          string `json:"book"`
	Bookcount     int64  `json:"bookcount"`
}

func (q *Queries) CreaterReturnAndBorrow(ctx context.Context, arg CreaterReturnAndBorrowParams) (Returnandborrow, error) {
	row := q.queryRow(ctx, q.createrReturnAndBorrowStmt, createrReturnAndBorrow, arg.FromAccountID, arg.Book, arg.Bookcount)
	var i Returnandborrow
	err := row.Scan(
		&i.ID,
		&i.FromAccountID,
		&i.Book,
		&i.Bookcount,
		&i.CreatedAt,
	)
	return i, err
}

const getTransfer = `-- name: GetTransfer :one
SELECT id, from_account_id, book, bookcount, created_at FROM returnandborrow
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTransfer(ctx context.Context, id int64) (Returnandborrow, error) {
	row := q.queryRow(ctx, q.getTransferStmt, getTransfer, id)
	var i Returnandborrow
	err := row.Scan(
		&i.ID,
		&i.FromAccountID,
		&i.Book,
		&i.Bookcount,
		&i.CreatedAt,
	)
	return i, err
}

const listTransfers = `-- name: ListTransfers :many
SELECT id, from_account_id, book, bookcount, created_at FROM returnandborrow
WHERE from_account_id = $1 OR book = $2
ORDER BY id
LIMIT $3
OFFSET $4
`

type ListTransfersParams struct {
	FromAccountID int64  `json:"fromAccountId"`
	Book          string `json:"book"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListTransfers(ctx context.Context, arg ListTransfersParams) ([]Returnandborrow, error) {
	rows, err := q.query(ctx, q.listTransfersStmt, listTransfers,
		arg.FromAccountID,
		arg.Book,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Returnandborrow
	for rows.Next() {
		var i Returnandborrow
		if err := rows.Scan(
			&i.ID,
			&i.FromAccountID,
			&i.Book,
			&i.Bookcount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
